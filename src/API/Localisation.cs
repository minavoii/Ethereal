using System;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using System.Linq;
using HarmonyLib;
using Newtonsoft.Json;
using UnityEngine;

namespace Ethereal.API;

public class Localisation
{
    [Serializable]
    internal class Language()
    {
        public string name = "Custom Language";

        /// <summary>
        /// The language code used for formatting numbers and such.
        /// </summary>
        public string code = "en-US";

        public string game_version = "0.0.0.0";

        /// <summary>
        /// Addons are loaded after other localisations files.<para/>
        /// They can be used to add localisations to another language (custom or native).
        /// </summary>
        public bool addon = false;

        public Dictionary<int, string> localisations = [];
    }

    /// <summary>
    /// Contains the name of all native and custom languages.
    /// </summary>
    private static readonly List<string> AllLanguageNames =
    [
        .. Enum.GetValues(typeof(ELanguage)).Cast<ELanguage>().Select(Loca.GetLanguageString),
    ];

    internal static readonly Dictionary<ELanguage, string> CustomLanguages = [];

    internal static readonly Dictionary<string, Dictionary<ELanguage, string>> Localisations = [];

    private static readonly string LOCALISATIONS_PATH = Path.Join(
        Plugin.ETHEREAL_PATH,
        "localisations"
    );

    private const string TEMPLATE_NAME = "template.json";

    private const string TEMPLATE_WARNING =
        "Do NOT edit this file directly!!! Make a copy first!!! It will get replaced every game update.";

    public static void AddLocalisedText(LocalisationData.LocalisationDataEntry entry)
    {
        var pair = LocalisationData.Instance.LocaEntries.FirstOrDefault(x =>
            x.Value.ID == entry.ID
        );

        // Update text
        if (pair.Value != null)
        {
            pair.Value.StringContent = entry.StringContent;
            pair.Value.StringContentEnglish = entry.StringContentEnglish;
            pair.Value.StringContentFrench = entry.StringContentFrench;
            pair.Value.StringContentGerman = entry.StringContentGerman;
            pair.Value.StringContentItalian = entry.StringContentItalian;
            pair.Value.StringContentJapanese = entry.StringContentJapanese;
            pair.Value.StringContentPortuguese = entry.StringContentPortuguese;
            pair.Value.StringContentRussian = entry.StringContentRussian;
            pair.Value.StringContentSimplifiedChinese = entry.StringContentSimplifiedChinese;
            pair.Value.StringContentSpanish = entry.StringContentSpanish;
        }
        // Add text
        else
        {
            LocalisationData.Instance.LocaEntries.Add(entry.StringContent, entry);
        }
    }

    public static void AddLocalisedText(
        LocalisationData.LocalisationDataEntry entry,
        Dictionary<string, string> customLanguageEntries
    )
    {
        AddLocalisedText(entry);

        foreach (var (langName, text) in customLanguageEntries)
        {
            var lang = CustomLanguages.FirstOrDefault(x => x.Value == langName);

            // Language not found found
            if (lang.Value == null)
                continue;

            // Update text
            if (Localisations.TryGetValue(entry.StringContent, out var dictionary))
            {
                // This specific language already has a localisation
                if (dictionary.ContainsKey(lang.Key))
                    dictionary[lang.Key] = text;
                // Other languages have a localisation but not this one
                else
                    Localisations[entry.StringContent].Add(lang.Key, text);
            }
            // Add text
            else
                Localisations.Add(entry.StringContent, new() { { lang.Key, text } });
        }
    }

    internal static void LoadLanguages()
    {
        List<Language> languageList = [];

        foreach (FileInfo file in new DirectoryInfo(LOCALISATIONS_PATH).EnumerateFiles())
        {
            if (file.Name == TEMPLATE_NAME)
                continue;

            string json = file.OpenText().ReadToEnd();
            Language language = JsonConvert.DeserializeObject<Language>(json);

            // Remove the "don't edit this file" warning from the template
            //   in case a modder forgot to remove it
            language.localisations.Remove(-1);
            languageList.Add(language);
        }

        foreach (Language language in languageList.OrderBy(x => x.addon))
        {
            API.Log.LogInfo($"Loaded locale: {language.name}");

            if (AllLanguageNames.Contains(language.name))
                UpdateLanguage(language);
            else
                CreateLanguage(language);
        }
    }

    private static void CreateLanguage(Language language)
    {
        var availableLanguages =
            (List<ELanguage>)
                AccessTools
                    .Field(typeof(LocalisationData), "availableLanguages")
                    .GetValue(LocalisationData.Instance);

        ELanguage langId =
            Enum.GetValues(typeof(ELanguage)).Cast<ELanguage>().Max() + 1 + CustomLanguages.Count;

        availableLanguages.Add(langId);
        CustomLanguages.Add(langId, language.name);
        AllLanguageNames.Add(language.name);

        foreach (var (locaId, text) in language.localisations)
        {
            if (
                PluginUtils.Collections.TryTakeKey(
                    LocalisationData.Instance.LocaEntries,
                    x => x.Value?.ID == locaId,
                    out var original
                )
            )
            {
                // Already localised in another custom language
                if (Localisations.TryGetValue(original, out var dict))
                    dict.Add(langId, text);
                // Not localised in any custom language yet
                else
                    Localisations.Add(original, new() { { langId, text } });
            }
            // Custom text that wasn't loaded yet
            // else { }
        }

        var CultureInfos =
            (Dictionary<ELanguage, CultureInfo>)
                AccessTools.Field(typeof(Utils), "CultureInfos").GetValue(null);

        if (CultureInfos == null)
        {
            CultureInfos = new Dictionary<ELanguage, CultureInfo>
            {
                { ELanguage.English, CultureInfo.CreateSpecificCulture("en-US") },
                { ELanguage.Chinese, CultureInfo.CreateSpecificCulture("zh-CN") },
                { ELanguage.French, CultureInfo.CreateSpecificCulture("fr-FR") },
                { ELanguage.German, CultureInfo.CreateSpecificCulture("de-DE") },
                { ELanguage.Italian, CultureInfo.CreateSpecificCulture("it-IT") },
                { ELanguage.Russian, CultureInfo.CreateSpecificCulture("ru-RU") },
                { ELanguage.Spanish, CultureInfo.CreateSpecificCulture("es-ES") },
                { ELanguage.Japanese, CultureInfo.CreateSpecificCulture("ja-JP") },
            };

            AccessTools.Field(typeof(Utils), "CultureInfos").SetValue(null, CultureInfos);
        }

        try
        {
            CultureInfos.Add(langId, CultureInfo.CreateSpecificCulture(language.code));
        }
        catch (CultureNotFoundException)
        {
            CultureInfos.Add(langId, CultureInfo.CreateSpecificCulture("en-US"));
        }
    }

    private static void UpdateLanguage(Language language)
    {
        foreach (var (locaId, text) in language.localisations)
        {
            var entry = LocalisationData
                .Instance.LocaEntries.FirstOrDefault(x => x.Value.ID == locaId)
                .Value;

            if (entry != null)
            {
                // Some of these languages aren't officially supported/added yet
                // If they are after a game update,
                //   we don't want modded translations to replace them by default
                // A Ethereal update would change this, but the user would
                //   be the one triggering it, so they wouldn't be surprised

                // Native languages
                if (language.name == Loca.GetLanguageString(ELanguage.English))
                    entry.StringContentEnglish = text;
                else if (language.name == Loca.GetLanguageString(ELanguage.German))
                    entry.StringContentGerman = text;
                /*else if (language.name == Loca.GetLanguageString(ELanguage.Spanish))
                    entry.StringContentSpanish = text;*/
                else if (language.name == Loca.GetLanguageString(ELanguage.Portuguese))
                    entry.StringContentPortuguese = text;
                else if (language.name == Loca.GetLanguageString(ELanguage.French))
                    entry.StringContentFrench = text;
                /*else if (language.name == Loca.GetLanguageString(ELanguage.Italian))
                    entry.StringContentItalian = text;*/
                /*else if (language.name == Loca.GetLanguageString(ELanguage.Russian))
                    entry.StringContentRussian = text;*/
                else if (language.name == Loca.GetLanguageString(ELanguage.Japanese))
                    entry.StringContentJapanese = text;
                else if (language.name == Loca.GetLanguageString(ELanguage.Chinese))
                    entry.StringContentSimplifiedChinese = text;
                // Custom language
                else
                {
                    if (
                        PluginUtils.Collections.TryTakeKey(
                            CustomLanguages,
                            x => x.Value == language.name,
                            out var key
                        )
                    )
                    {
                        // Update text
                        if (Localisations.TryGetValue(entry.StringContent, out var dictionary))
                        {
                            // This specific language already has a localisation
                            if (dictionary.ContainsKey(key))
                                dictionary[key] = text;
                            // Other languages have a localisation but not this one
                            else
                                Localisations[entry.StringContent].Add(key, text);
                        }
                        // Add text
                        else
                            Localisations.Add(entry.StringContent, new() { { key, text } });
                    }
                }
            }
            // Custom text that wasn't loaded yet
            // else { }
        }
    }

    internal static void GenerateTemplate()
    {
        // Only regenerate the template after updating to a new version
        //  or if it wasn't found
        if (GetTemplateVersion() == Application.version)
            return;

        Language lang = new() { name = "English", game_version = Application.version };
        lang.localisations.Add(-1, TEMPLATE_WARNING);

        foreach (var (text, loca) in LocalisationData.Instance.LocaEntries.OrderBy(x => x.Value.ID))
        {
            lang.localisations.Add(loca.ID, text);
        }

        string json = JsonConvert.SerializeObject(lang, Formatting.Indented);
        Directory.CreateDirectory(LOCALISATIONS_PATH);
        File.WriteAllText(Path.Join(LOCALISATIONS_PATH, TEMPLATE_NAME), json);
    }

    private static string GetTemplateVersion()
    {
        try
        {
            string template_json = File.ReadAllText(Path.Join(LOCALISATIONS_PATH, TEMPLATE_NAME));
            Language lang = JsonConvert.DeserializeObject<Language>(template_json);

            return lang.game_version ?? "0.0.0.0";
        }
        catch
        {
            return "0.0.0.0";
        }
    }
}
